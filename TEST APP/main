# import numpy as np
# import logging
# from tqdm import tqdm

# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# class Vector:
#     length_constraint= 0
#     element_constraints= np.array([])
#     dtype = float

#     def __init__(self, values=None):
#         if values is None:
#             values = self.generate_default_values()

#         if not all(isinstance(val, self.dtype) for val in values):
#             logging.warning("Преобразование типов: входные данные не соответствуют типу %s", self.dtype)
                
#         self.values = np.array(values, dtype=self.dtype)
#         self.constrain_elements()

#         if not self.check_constraints():
#             logging.error("Вектор не соответствует заданным ограничениям при инициализации.")
#             raise ValueError("Вектор не соответствует заданным ограничениям: %s" % self.values)

#         logging.info("Вектор успешно инициализирован: %s", self.values)

#     def generate_default_values(self):
#         if self.length_constraint <= 0:
#             raise ValueError("Length constraint must be greater than zero to generate default values.")

#         if self.element_constraints.size > 0:
#             lower_bounds, upper_bounds = self.element_constraints[:, 0], self.element_constraints[:, 1]
#             return np.random.uniform(lower_bounds, upper_bounds, self.length_constraint)
#         else:
#             return np.zeros(self.length_constraint, dtype=self.dtype)

#     def check_constraints(self):
#         if self.length_constraint is not None and len(self.values) != self.length_constraint:
#             logging.error("Длина вектора %d не соответствует ограничению %d", len(self.values), self.length_constraint)
#             return False
        
#         self.constrain_elements()
#         return True

#     def constrain_elements(self):
#         """Приводит элементы вектора к ближайшим допустимым значениям в соответствии с ограничениями."""
#         if len(self.element_constraints) > 0:
#             lower_bounds, upper_bounds = self.element_constraints[:, 0], self.element_constraints[:, 1]

#             if np.any(self.values < lower_bounds) or np.any(self.values > upper_bounds):
#                 logging.error(f"Элемент {self.values} меньше или больше ограничений {self.element_constraints}")

#             self.values = np.clip(self.values, lower_bounds, upper_bounds)

#     def __len__(self):
#         return len(self.values)

#     def __getitem__(self, index):
#         return self.values[index]

#     def __setitem__(self, index, value):
#         self.values[index] = value
#         self.constrain_elements()

#         if not self.check_constraints():
#             logging.error("Изменение элемента приводит к несоответствию ограничениям: %s", self.values)
#             raise ValueError("Изменение элемента приводит к несоответствию ограничениям.")

#     def __iter__(self):
#         return iter(self.values)

#     def __add__(self, other):
#         result = self._perform_operation(other, np.add)
#         logging.info("Выполнено сложение двух векторов.")
#         return result

#     def __sub__(self, other):
#         result = self._perform_operation(other, np.subtract)
#         logging.info("Выполнено вычитание двух векторов.")
#         return result

#     def __mul__(self, other):
#         result = self._perform_operation(other, np.multiply)
#         logging.info("Выполнено умножение двух векторов.")
#         return result

#     def __truediv__(self, other):
#         result = self._perform_operation(other, np.divide)
#         logging.info("Выполнено деление двух векторов.")
#         return result

#     def _perform_operation(self, other, operation):
#         if isinstance(other, Vector):
#             new_values = operation(self.values, other.values)
#         else:
#             new_values = operation(self.values, other)
#         result_vector = Vector(new_values)
#         return result_vector

#     def __repr__(self):
#         return f"Вектор {self.values}"

# # Класс для описания задачи оптимизации
# class OptimizationProblem:
#     def __init__(self, f_objective = [], f_constraints = [], v_constraints = {}):
#         """
#         :param initial_vector: Исходный вектор, который мы оптимизируем.
#         :param f_objective: Список целевых функций, которые мы хотим оптимизировать.
#         :param f_constraints: Список функций-ограничений, которым должен соответствовать вектор.
#         :param v_constraints: Список ограничений, которым должен соответствовать вектор.
#         """
#         self.f_objective = f_objective
#         self.f_constraints = f_constraints
#         self.set_vector_const(v_constraints)

#     def set_vector_const(self, v_constraints = {}):
#         for key, item in v_constraints.items():
#             match key:
#                 case 'len':
#                     Vector.length_constraint = item
#                 case 'constraints':
#                     Vector.element_constraints = np.array(item)
#                 case 'dtype':
#                     Vector.dtype = item
                    
#     def evaluate_objectives(self, vector=None):
#         """Оценивает все целевые функции на заданном векторе. Возвращает список значений."""
#         self.objective = [f(vector) for f in self.f_objective]
#         return self.objective

#     def check_constraints(self, vector=None):
#         """Проверяет, выполняются ли все ограничения на заданном векторе."""
#         self.constraints = all(c(vector) for c in self.f_constraints)
#         return self.constraints

#     def print_info(self):
#         """Выводит информацию о целевых функциях и ограничениях."""
#         print("Целевые функции:")
#         for f in self.f_objective:
#             print(f" - {f.__name__}")

#         print("Ограничения:")
#         for c in self.f_constraints:
#             print(f" - {c.__name__}")

# class NetworkOptimizationProblem(OptimizationProblem):
#     def __init__(self, network_graph, task_graph, f_objective=[], f_constraints=[], v_constraints={}):
#         """
#         :param network_graph: Граф сети, представленный с помощью NetworkX.
#         :param task_graph: Граф задач, представленный с помощью NetworkX.
#         :param f_objective: Список целевых функций, которые мы хотим оптимизировать.
#         :param f_constraints: Список функций-ограничений, которым должно соответствовать распределение.
#         :param v_constraints: Список ограничений, которым должен соответствовать вектор (например, размер сети).
#         """

#         super().__init__(f_objective, f_constraints, v_constraints)
#         self.network_graph = network_graph
#         self.task_graph = task_graph

#     def distribute_tasks(self):
#         """
#         Метод для генерации начального распределения задач на узлы сети.
#         """
#         num_tasks = len(self.task_graph)
#         num_nodes = len(self.network_graph)
        
#         # Пример равномерного начального распределения задач
#         initial_distribution = np.random.choice(num_nodes, num_tasks)
#         return initial_distribution

#     def evaluate_distribution(self, distribution):
#         """
#         Оценивает эффективность текущего распределения задач.
#         :param distribution: Список или массив, указывающий на какой узел распределена каждая задача.
#         """
#         # Реализуем оценку распределения на основе выбранной целевой функции
#         objective_values = self.evaluate_objectives(distribution)
#         return np.prod(objective_values)

#     def check_network_constraints(self, distribution):
#         """
#         Проверяет, выполняются ли все сетевые ограничения для данного распределения.
#         """
#         return self.check_constraints(distribution)

# # Базовый класс для реализаций оптимизаций
# class Optimizer:
#     def __init__(self, problem, track_history=True):
#         """
#         :param problem: Экземпляр OptimizationProblem или подкласс OptimizationProblem.
#         :param track_history: Флаг, указывающий, нужно ли вести историю итераций.
#         """
#         self.problem = problem
#         self.track_history = track_history
#         self.history = [] if track_history else None

#     def optimize(self):
#         """Метод, который должен быть реализован в подклассе."""
#         raise NotImplementedError("Метод 'optimize' должен быть реализован в подклассе.")

#     def update_history(self, iteration, vector):
#         """Обновляет историю, если она включена."""
#         if self.track_history:
#             self.history.append({'iteration': iteration, 'vector': vector.copy()})

# class PS(Optimizer):
#     def __init__(self, problem, iterations=100_000, num_particles = 100, omega = 0.7, phi_p = 0.7, phi_g = 0.7, track_history=True):
#         super().__init__(problem, track_history)
#         self.iterations = iterations
#         self.num_particles = num_particles
#         self.omega = omega
#         self.phi_p = phi_p
#         self.phi_g = phi_g
#         self.global_best_position = Vector()
#         self.global_best_score = self.problem.evaluate_distribution(self.global_best_position)

#     def optimize(self):

#         self.particles = [Vector() for _ in range(self.num_particles)]

#         f_calls = len(self.particles)
#         self.update_history(f_calls, self.global_best_position)

#         for _ in tqdm(range(self.iterations), desc="Optimizing"):
#             for particle in self.particles:
#                 score = getattr(particle,'Свертка')

#                 if score > particle.best_score:
#                     particle.best_position = particle
#                     particle.best_score = score

#                 if score > self.global_best_score:
#                     self.global_best_position = particle
#                     self.global_best_score = score

#             for particle in self.particles:
#                 particle.update_velocity(self.global_best_position, self.omega, self.phi_p, self.phi_g)
#                 particle.update_distribution()
#                 f_calls += 1
#             self.update_history(f_calls, self.global_best_position)


# # Пример конкретного алгоритма оптимизации
# class SimpleOptimizer(Optimizer):
#     def __init__(self, problem, iterations=10000000, track_history=True):
#         super().__init__(problem, track_history)
#         self.iterations = iterations

#     def optimize(self):
#         logging.info("Начало оптимизации простым алгоритмом")
#         best_vector = self.problem.vector
#         best_value = float('inf')

#         for i in tqdm(range(self.iterations), desc="Optimizing"):
#             candidate = best_vector + np.random.uniform(-0.1, 0.1, len(self.problem.vector))
            
#             if self.problem.check_constraints(candidate):
#                 current_value = min(self.problem.evaluate_objectives(candidate))
#                 if current_value < best_value:
#                     best_value = current_value
#                     best_vector = candidate.copy()
                
#                 self.update_history(i, candidate, current_value)

#         self.problem.vector = best_vector
#         logging.info(f"Лучший вектор: {self.problem.vector} с значением: {best_value}")